package tools;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.*;

/**
 * ApiWriter - Generates .api documentation files from Java source code.
 * Extracts class signatures, method definitions, and documentation for AI consumption.
 *
 * @author HelloWorld Project
 * @version 1.0
 */
public class ApiWriter {

    private static final String VERSION = "1.0";
    private static final Pattern CLASS_PATTERN = Pattern.compile(
        "(?:^|\\n)\\s*(?:public\\s+|private\\s+|protected\\s+)?(?:static\\s+)?(?:final\\s+)?(?:abstract\\s+)?class\\s+(\\w+)");
    private static final Pattern METHOD_PATTERN = Pattern.compile(
        "(?:^|\\n)\\s*((?:public|private|protected)\\s+(?:static\\s+)?[\\w<>\\[\\],\\s]+\\s+(\\w+)\\s*\\([^)]*\\))");
    private static final Pattern JAVADOC_PATTERN = Pattern.compile(
        "/\\*\\*([^*]|\\*(?!/))*\\*/");

    /**
     * Main entry point for API generation.
     *
     * @param args Command line arguments: [input_path] [output_path]
     */
    public static void main(String[] args) {
        try {
            if (args.length == 0 || args[0].equals("--help") || args[0].equals("-h")) {
                printUsage();
                return;
            }

            String inputPath = args[0];
            String outputPath = args.length > 1 ? args[1] : null;

            Path input = Paths.get(inputPath);
            assert Files.exists(input) : "Input path must exist: " + inputPath;

            if (Files.isDirectory(input)) {
                generatePackageApi(input, outputPath);
            } else if (inputPath.endsWith(".java")) {
                generateClassApi(input, outputPath);
            } else {
                throw new IllegalArgumentException("Input must be .java file or directory: " + inputPath);
            }

        } catch (Exception e) {
            System.err.println("ApiWriter Error: " + e.getMessage());
            if (args.length > 0 && (args[0].equals("--verbose") || args[0].equals("-v"))) {
                e.printStackTrace();
            }
            System.exit(1);
        }
    }

    /**
     * Generates API documentation for an entire package directory.
     *
     * @param packageDir Directory containing Java source files
     * @param outputPath Output file path (optional)
     * @throws IOException if file operations fail
     */
    private static void generatePackageApi(Path packageDir, String outputPath) throws IOException {
        assert Files.isDirectory(packageDir) : "Package path must be directory";

        String packageName = packageDir.getFileName().toString();
        StringBuilder api = new StringBuilder();

        // Header
        api.append("# Package ").append(packageName).append(" API\n");
        api.append("*Generated by ApiWriter v").append(VERSION).append("*\n");
        api.append("*Package documentation for ").append(packageName).append(" package*\n\n");

        // Find all Java files
        List<Path> javaFiles = new ArrayList<>();
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(packageDir, "*.java")) {
            for (Path file : stream) {
                javaFiles.add(file);
            }
        }

        if (javaFiles.isEmpty()) {
            throw new IllegalArgumentException("No Java files found in: " + packageDir);
        }

        // Sort for consistent output
        javaFiles.sort(Comparator.comparing(Path::getFileName));

        api.append("## Core Classes\n\n");

        // Process each Java file
        for (Path javaFile : javaFiles) {
            String classApi = generateClassApiContent(javaFile);
            api.append(classApi).append("\n");
        }

        // Footer
        api.append("---\n");
        api.append("*Package ").append(packageName);
        api.append(" provides core functionality with professional error handling*\n");
        api.append("*All classes follow defensive programming principles with comprehensive assertions*\n");

        // Write output
        if (outputPath != null) {
            Files.write(Paths.get(outputPath), api.toString().getBytes());
            System.out.println("Generated package API: " + outputPath);
        } else {
            System.out.print(api.toString());
        }
    }

    /**
     * Generates API documentation for a single Java class file.
     *
     * @param javaFile Path to Java source file
     * @param outputPath Output file path (optional)
     * @throws IOException if file operations fail
     */
    private static void generateClassApi(Path javaFile, String outputPath) throws IOException {
        assert Files.exists(javaFile) : "Java file must exist";
        assert javaFile.toString().endsWith(".java") : "Input must be .java file";

        String className = javaFile.getFileName().toString().replace(".java", "");
        StringBuilder api = new StringBuilder();

        // Header
        api.append("# ").append(className).append(" API\n");
        api.append("*Generated by ApiWriter v").append(VERSION).append("*\n");
        api.append("*Class documentation for ").append(className).append("*\n\n");

        // Generate class content
        String classContent = generateClassApiContent(javaFile);
        api.append(classContent);

        // Write output
        if (outputPath != null) {
            Files.write(Paths.get(outputPath), api.toString().getBytes());
            System.out.println("Generated class API: " + outputPath);
        } else {
            System.out.print(api.toString());
        }
    }

    /**
     * Generates API content for a single Java class.
     *
     * @param javaFile Path to Java source file
     * @return API content string
     * @throws IOException if file reading fails
     */
    private static String generateClassApiContent(Path javaFile) throws IOException {
        String content = new String(Files.readAllBytes(javaFile));
        String className = javaFile.getFileName().toString().replace(".java", "");

        StringBuilder api = new StringBuilder();

        // Extract class documentation
        String classDoc = extractClassDocumentation(content);

        api.append("<class ").append(className).append(">\n");
        if (classDoc != null && !classDoc.trim().isEmpty()) {
            api.append("*").append(classDoc.trim()).append("*\n");
        }

        // Extract class declaration
        String classDecl = extractClassDeclaration(content, className);
        if (classDecl != null) {
            api.append(classDecl).append("\n\n");
        }

        // Extract methods
        List<MethodInfo> methods = extractMethods(content);
        if (!methods.isEmpty()) {
            api.append("#Methods\n");
            for (MethodInfo method : methods) {
                if (method.documentation != null && !method.documentation.trim().isEmpty()) {
                    api.append("*").append(method.documentation.trim()).append("*\n");
                }
                api.append(method.signature).append("\n\n");
            }
        }

        api.append("</class ").append(className).append(">\n");

        return api.toString();
    }

    /**
     * Extracts class-level documentation from JavaDoc comments.
     *
     * @param content Java source content
     * @return Class documentation or null if not found
     */
    private static String extractClassDocumentation(String content) {
        Matcher javadocMatcher = JAVADOC_PATTERN.matcher(content);
        Matcher classMatcher = CLASS_PATTERN.matcher(content);

        if (classMatcher.find()) {
            int classStart = classMatcher.start();

            // Find the closest JavaDoc before the class
            String beforeClass = content.substring(0, classStart);
            Matcher beforeMatcher = JAVADOC_PATTERN.matcher(beforeClass);

            String lastJavadoc = null;
            while (beforeMatcher.find()) {
                lastJavadoc = beforeMatcher.group();
            }

            if (lastJavadoc != null) {
                return cleanJavadoc(lastJavadoc);
            }
        }

        return "Class documentation not available";
    }

    /**
     * Extracts the class declaration line.
     *
     * @param content Java source content
     * @param className Expected class name
     * @return Class declaration or null if not found
     */
    private static String extractClassDeclaration(String content, String className) {
        String[] lines = content.split("\n");
        for (String line : lines) {
            String trimmed = line.trim();
            if (trimmed.contains("class " + className) &&
                (trimmed.startsWith("public") || trimmed.startsWith("class"))) {
                return trimmed.replaceAll("\\{.*", "").trim();
            }
        }
        return "public class " + className;
    }

    /**
     * Extracts method information from Java source.
     *
     * @param content Java source content
     * @return List of method information
     */
    private static List<MethodInfo> extractMethods(String content) {
        List<MethodInfo> methods = new ArrayList<>();

        String[] lines = content.split("\n");
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i].trim();

            // Look for method signatures
            if (isMethodLine(line)) {
                String methodSignature = extractMethodSignature(lines, i);
                String methodDoc = extractMethodDocumentation(lines, i);

                if (methodSignature != null) {
                    methods.add(new MethodInfo(methodSignature, methodDoc));
                }
            }
        }

        return methods;
    }

    /**
     * Checks if a line contains a method declaration.
     *
     * @param line Source code line
     * @return true if line appears to be a method declaration
     */
    private static boolean isMethodLine(String line) {
        return (line.contains("public ") || line.contains("private ") || line.contains("protected ")) &&
               line.contains("(") &&
               !line.contains("class ") &&
               !line.contains("interface ") &&
               !line.contains("=") &&
               (line.contains("static ") || line.contains("void ") ||
                line.matches(".*\\s+(\\w+)\\s*\\(.*"));
    }

    /**
     * Extracts complete method signature, handling multi-line declarations.
     *
     * @param lines All source lines
     * @param startIndex Index of method start
     * @return Complete method signature
     */
    private static String extractMethodSignature(String[] lines, int startIndex) {
        StringBuilder signature = new StringBuilder();

        for (int i = startIndex; i < lines.length; i++) {
            String line = lines[i].trim();
            signature.append(line);

            if (line.contains("{")) {
                break;
            }
            if (line.endsWith(")") || line.endsWith(");")) {
                break;
            }

            signature.append(" ");
        }

        return signature.toString()
                      .replaceAll("\\{.*", "")
                      .replaceAll(";$", "")
                      .trim();
    }

    /**
     * Extracts method documentation from preceding JavaDoc.
     *
     * @param lines All source lines
     * @param methodIndex Index of method declaration
     * @return Method documentation or default
     */
    private static String extractMethodDocumentation(String[] lines, int methodIndex) {
        // Look backwards for JavaDoc
        for (int i = methodIndex - 1; i >= 0; i--) {
            String line = lines[i].trim();

            if (line.equals("*/")) {
                // Found end of JavaDoc, extract it
                StringBuilder doc = new StringBuilder();
                for (int j = i; j >= 0; j--) {
                    String docLine = lines[j].trim();
                    if (docLine.startsWith("/**")) {
                        // Extract the actual content
                        String content = doc.toString();
                        return cleanJavadoc("/**" + content + "*/");
                    }
                    doc.insert(0, docLine);
                }
            }

            if (!line.isEmpty() && !line.startsWith("@") && !line.startsWith("*")) {
                break; // Hit non-JavaDoc content
            }
        }

        return "Method documentation not available";
    }

    /**
     * Cleans JavaDoc text for API output.
     *
     * @param javadoc Raw JavaDoc text
     * @return Cleaned documentation text
     */
    private static String cleanJavadoc(String javadoc) {
        return javadoc.replaceAll("/\\*\\*|\\*/", "")
                     .replaceAll("\\n\\s*\\*", " ")
                     .replaceAll("\\s+", " ")
                     .trim();
    }

    /**
     * Prints usage information.
     */
    private static void printUsage() {
        System.err.println("ApiWriter v" + VERSION + " - Generate .api documentation from Java source");
        System.err.println();
        System.err.println("Usage:");
        System.err.println("  java tools.ApiWriter <input> [output]");
        System.err.println();
        System.err.println("  input   - Java file (.java) or package directory");
        System.err.println("  output  - Output .api file (optional, defaults to stdout)");
        System.err.println();
        System.err.println("Examples:");
        System.err.println("  java tools.ApiWriter hello/HelloTool.java api/HelloTool.api");
        System.err.println("  java tools.ApiWriter hello/ api/package_hello.api");
        System.err.println("  java tools.ApiWriter world/");
        System.err.println();
        System.err.println("Options:");
        System.err.println("  --help, -h     Show this help");
        System.err.println("  --verbose, -v  Show detailed error information");
    }

    /**
     * Internal class to hold method information.
     */
    private static class MethodInfo {
        final String signature;
        final String documentation;

        MethodInfo(String signature, String documentation) {
            this.signature = signature;
            this.documentation = documentation;
        }
    }
}